From 8ae62e3f5c277fa74f3c8b5f37f661059259ca5b Mon Sep 17 00:00:00 2001
From: Frank Du <frank.du@intel.com>
Date: Wed, 22 Feb 2023 10:06:28 +0800
Subject: [PATCH 2/2] test: add seprate send and recv with multi session
 support

usage:
./build/test/rist/test_send --sleep_us 1 --sleep_step 3 --dip
192.168.18.102 --sessions_cnt 1
./build/test/rist/test_receive --bind_ip 192.168.18.102 --sessions_cnt 1

MUFD_CFG=test/rist/ufd_receive.json ./build/test/rist/test_receive --sessions_cnt 1
 MUFD_CFG=test/rist/ufd_send.json ./build/test/rist/test_send --sleep_us
1 --sleep_step 3 --dip 192.168.85.80 --sessions_cnt 1

Signed-off-by: Frank Du <frank.du@intel.com>
---
 0001-mtl-add-mtl-build-support.patch          | 864 ++++++++++++++++++
 ...-send-and-recv-with-multi-session-su.patch | 778 ++++++++++++++++
 0003-fix-kernel-path.patch                    | 111 +++
 test/rist/meson.build                         |  19 +
 test/rist/test_receive.c                      | 245 +++++
 test/rist/test_send.c                         | 236 +++++
 test/rist/test_util.c                         | 108 +++
 test/rist/test_util.h                         |  65 ++
 test/rist/ufd_receive.json                    |  13 +
 test/rist/ufd_send.json                       |  13 +
 10 files changed, 2452 insertions(+)
 create mode 100644 0001-mtl-add-mtl-build-support.patch
 create mode 100644 0002-test-add-seprate-send-and-recv-with-multi-session-su.patch
 create mode 100644 0003-fix-kernel-path.patch
 create mode 100644 test/rist/test_receive.c
 create mode 100644 test/rist/test_send.c
 create mode 100644 test/rist/test_util.c
 create mode 100644 test/rist/test_util.h
 create mode 100644 test/rist/ufd_receive.json
 create mode 100644 test/rist/ufd_send.json

diff --git a/0001-mtl-add-mtl-build-support.patch b/0001-mtl-add-mtl-build-support.patch
new file mode 100644
index 0000000..1f2c45e
--- /dev/null
+++ b/0001-mtl-add-mtl-build-support.patch
@@ -0,0 +1,864 @@
+From b9e2a9ccd2d8b046fc922c7a3768db74e5b8eea9 Mon Sep 17 00:00:00 2001
+From: Frank Du <frank.du@intel.com>
+Date: Wed, 22 Feb 2023 10:03:58 +0800
+Subject: [PATCH 1/3] mtl: add mtl build support
+
+./build_with_mtl.sh
+
+Signed-off-by: Frank Du <frank.du@intel.com>
+---
+ build.sh                    |   9 +
+ build_with_mtl.sh           |   9 +
+ include/librist/udpsocket.h |  73 ++++--
+ meson.build                 |  11 +
+ meson_options.txt           |   1 +
+ src/eap.c                   |   6 +-
+ src/libevsocket.c           |   4 +-
+ src/rist-common.c           |   4 +-
+ src/udp.c                   |   7 +-
+ src/udpsocket.c             | 487 +++++++++++++++++++++++++-----------
+ 10 files changed, 436 insertions(+), 175 deletions(-)
+ create mode 100755 build.sh
+ create mode 100755 build_with_mtl.sh
+
+diff --git a/build.sh b/build.sh
+new file mode 100755
+index 0000000..fea92d1
+--- /dev/null
++++ b/build.sh
+@@ -0,0 +1,9 @@
++#!/bin/bash
++
++set -e
++
++#meson build -Dbuildtype=debug
++meson build
++ninja -C build
++cd build
++#sudo ninja install
+diff --git a/build_with_mtl.sh b/build_with_mtl.sh
+new file mode 100755
+index 0000000..1971287
+--- /dev/null
++++ b/build_with_mtl.sh
+@@ -0,0 +1,9 @@
++#!/bin/bash
++
++set -e
++
++#meson build -Duse_mtl=true -Dbuildtype=debug
++meson build -Duse_mtl=true
++ninja -C build
++cd build
++#sudo ninja install
+diff --git a/include/librist/udpsocket.h b/include/librist/udpsocket.h
+index 717b301..be2579d 100644
+--- a/include/librist/udpsocket.h
++++ b/include/librist/udpsocket.h
+@@ -43,6 +43,10 @@ typedef int socklen_t;
+ #include <poll.h>
+ #endif /* Windows / POSIX */
+ 
++#ifdef RIST_HAS_MTL
++#include <mtl/mudp_sockfd_api.h>
++#endif
++
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+@@ -55,6 +59,21 @@ typedef struct udpsocket_url_param {
+ 	char *val;
+ } udpsocket_url_param_t;
+ 
++#ifdef RIST_HAS_MTL
++RIST_API int udpsocket_open(uint16_t af);
++RIST_API int udpsocket_bind(int sd, const char *host, uint16_t port);
++RIST_API int udpsocket_open_bind(const char *host, uint16_t port, const char *mciface);
++RIST_API int udpsocket_open_connect(const char *host, uint16_t port, const char *mciface);
++RIST_API int udpsocket_close(int sd);
++RIST_API int udpsocket_send(int sd, const void *buf, size_t size);
++RIST_API int udpsocket_recvfrom(int sd, void *buf, size_t size, int flags, struct sockaddr *addr, socklen_t *addr_len);
++RIST_API int udpsocket_set_nonblocking(int sd);
++RIST_API ssize_t udp_sendto(int sockfd, const void *buf, size_t len, int flags,
++                      const struct sockaddr *dest_addr, socklen_t addrlen);
++RIST_API int udpsocket_send_nonblocking(int sd, const void *buf, size_t size);
++RIST_API int udp_poll(struct pollfd* fds, nfds_t nfds, int timeout);
++RIST_API int udp_fcntl(int fd, int cmd, long arg);
++#else
+ /* Open a udp socket of family [af]
+  *
+  * Returns: socket descriptor, -1 for error (errno is set)
+@@ -72,6 +91,36 @@ RIST_API int udpsocket_open(uint16_t af);
+  */
+ RIST_API int udpsocket_open_bind(const char *host, uint16_t port, const char *mciface);
+ 
++/*
++ * Explicitly set the mcast interface for the socket [sd] to [mciface] for address
++ * family [family].
++ * Returns 0 on success, -1 on error (errno is set accordingly).
++ */
++RIST_API int udpsocket_set_mcast_iface(int sd, const char *mciface, uint16_t family);
++
++/* Open a udp socket and connect it to remote [host] + [port].
++ *
++ * binds to multicast interface [mciface], (if not NULL).
++ *
++ * Returns: socket descriptor, -1 for error (errno is set)
++ * (In case of gai_error, -1 is returned, errno is not set, check gai_error)
++ *
++ */
++RIST_API int udpsocket_open_connect(const char *host, uint16_t port, const char *mciface);
++
++RIST_API int udpsocket_set_nonblocking(int sd);
++RIST_API int udpsocket_send(int sd, const void *buf, size_t size);
++RIST_API int udpsocket_send_nonblocking(int sd, const void *buf, size_t size);
++RIST_API int udpsocket_sendto(int sd, const void *buf, size_t size, const char *host, uint16_t port);
++RIST_API int udpsocket_recv(int sd, void *buf, size_t size);
++RIST_API int udpsocket_recvfrom(int sd, void *buf, size_t size, int flags, struct sockaddr *addr, socklen_t *addr_len);
++RIST_API int udpsocket_close(int sd);
++RIST_API ssize_t udp_sendto(int sockfd, const void *buf, size_t len, int flags,
++                      const struct sockaddr *dest_addr, socklen_t addrlen);
++RIST_API int udp_poll(struct pollfd* fds, nfds_t nfds, int timeout);
++RIST_API int udp_fcntl(int fd, int cmd, long arg);
++#endif
++
+ /*
+  * Try to set RX buffer to 1Mbyte and fallback to 256Kbytes if that fails
+  * Returns -1 on error, 0 on success.
+@@ -110,32 +159,8 @@ RIST_API uint32_t udpsocket_get_buffer_size(int sd);
+  */
+ RIST_API uint32_t udpsocket_get_buffer_send_size(int sd);
+ 
+-/*
+- * Explicitly set the mcast interface for the socket [sd] to [mciface] for address
+- * family [family].
+- * Returns 0 on success, -1 on error (errno is set accordingly).
+- */
+-RIST_API int udpsocket_set_mcast_iface(int sd, const char *mciface, uint16_t family);
+-
+-/* Open a udp socket and connect it to remote [host] + [port].
+- *
+- * binds to multicast interface [mciface], (if not NULL).
+- *
+- * Returns: socket descriptor, -1 for error (errno is set)
+- * (In case of gai_error, -1 is returned, errno is not set, check gai_error)
+- *
+- */
+-RIST_API int udpsocket_open_connect(const char *host, uint16_t port, const char *mciface);
+-
+ RIST_API int udpsocket_resolve_host(const char *host, uint16_t port, struct sockaddr *addr);
+ 
+-RIST_API int udpsocket_set_nonblocking(int sd);
+-RIST_API int udpsocket_send(int sd, const void *buf, size_t size);
+-RIST_API int udpsocket_send_nonblocking(int sd, const void *buf, size_t size);
+-RIST_API int udpsocket_sendto(int sd, const void *buf, size_t size, const char *host, uint16_t port);
+-RIST_API int udpsocket_recv(int sd, void *buf, size_t size);
+-RIST_API int udpsocket_recvfrom(int sd, void *buf, size_t size, int flags, struct sockaddr *addr, socklen_t *addr_len);
+-RIST_API int udpsocket_close(int sd);
+ RIST_API int udpsocket_parse_url(char *url, char *address, int address_maxlen, uint16_t *port, int *local);
+ RIST_API int udpsocket_parse_url_parameters(const char *url, udpsocket_url_param_t *params,
+          int max_params, uint32_t *clean_url_len);
+diff --git a/meson.build b/meson.build
+index 1fc7e55..cb7f5d5 100755
+--- a/meson.build
++++ b/meson.build
+@@ -157,6 +157,17 @@ if not cc.check_header('stdatomic.h')
+     endif
+ endif
+ 
++if get_option('use_mtl')
++  mtl = dependency('mtl', required : false)
++  if mtl.found()
++    add_global_arguments('-DRIST_HAS_MTL', language : 'c')
++    deps += mtl
++    message('Build with mtl UDP stack')
++  else
++    error('mtl not found')
++  endif
++endif
++
+ #On ubuntu cjson does not come with pkgconfig files, hence the extended checking.
+ if not builtin_cjson
+ 	cjson_lib = dependency('libcjson', required: false)
+diff --git a/meson_options.txt b/meson_options.txt
+index 5232dfa..e63ec5f 100644
+--- a/meson_options.txt
++++ b/meson_options.txt
+@@ -10,3 +10,4 @@ option('have_mingw_pthreads', type: 'boolean', value: false)
+ option('allow_insecure_iv_fallback', type: 'boolean', value: false)
+ option('allow_obj_filter', type: 'boolean', value: false)
+ option('use_tun', type: 'boolean', value: false)
++option('use_mtl', type: 'boolean', value: false)
+diff --git a/src/eap.c b/src/eap.c
+index d1acd5b..85114f1 100644
+--- a/src/eap.c
++++ b/src/eap.c
+@@ -87,7 +87,7 @@ static int send_eapol_pkt(struct eapsrp_ctx *ctx, uint8_t eapoltype, uint8_t eap
+ 		ctx->timeout_retries = 0;
+ 	}
+ 
+-	ssize_t bytes = sendto(ctx->peer->sd, (const char *)buf, (EAPOL_EAP_HDRS_OFFSET + payload_len), 0, &ctx->peer->u.address, ctx->peer->address_len);
++	ssize_t bytes = udp_sendto(ctx->peer->sd, (const char *)buf, (EAPOL_EAP_HDRS_OFFSET + payload_len), 0, &ctx->peer->u.address, ctx->peer->address_len);
+ 	if (bytes != (ssize_t)(offset + payload_len))
+ 	{
+ 		//sockerr
+@@ -521,7 +521,7 @@ int eap_start(struct eapsrp_ctx *ctx)
+ 	struct eapol_hdr *eapol = (struct eapol_hdr *)&outpkt[sizeof(*gre)];
+ 	eapol->eapversion = 2;
+ 	eapol->eaptype = EAPOL_TYPE_START;
+-	sendto(ctx->peer->sd, (const char *)outpkt, (sizeof(*gre) + sizeof(*eapol)), 0, &ctx->peer->u.address, ctx->peer->address_len);
++	udp_sendto(ctx->peer->sd, (const char *)outpkt, (sizeof(*gre) + sizeof(*eapol)), 0, &ctx->peer->u.address, ctx->peer->address_len);
+ 	//CHECK
+ 	return 0;
+ }
+@@ -627,7 +627,7 @@ void eap_periodic(struct eapsrp_ctx *ctx)
+ 	{
+ 		if (ctx->last_pkt)
+ 		{
+-			sendto(ctx->peer->sd, (const char *)ctx->last_pkt, ctx->last_pkt_size, 0, &ctx->peer->u.address, ctx->peer->address_len);
++			udp_sendto(ctx->peer->sd, (const char *)ctx->last_pkt, ctx->last_pkt_size, 0, &ctx->peer->u.address, ctx->peer->address_len);
+ 			//check
+ 			ctx->timeout_retries++;
+ 			ctx->last_timestamp = now;
+diff --git a/src/libevsocket.c b/src/libevsocket.c
+index 56e319e..bc500ff 100755
+--- a/src/libevsocket.c
++++ b/src/libevsocket.c
+@@ -206,7 +206,7 @@ static void rebuild_poll(struct evsocket_ctx *ctx)
+ 	}
+ 
+ 	if (ctx->n_events > 0) {
+-		ctx->pfd = malloc(sizeof(struct pollfd) * ctx->n_events);
++		ctx->pfd = malloc(sizeof(*ctx->pfd) * ctx->n_events);
+ 		ctx->_array = calloc(sizeof(struct evsocket_event), ctx->n_events);
+ 	}
+ 
+@@ -323,7 +323,7 @@ int evsocket_loop_single(struct evsocket_ctx *ctx, int timeout, int max_events)
+ 		goto loop_error;
+ 	}
+ 
+-	pollret = poll(ctx->pfd, ctx->n_events, timeout);
++	pollret = udp_poll(ctx->pfd, ctx->n_events, timeout);
+ 	if (pollret <= 0) {
+ 		if (pollret < 0) {
+ 			rist_log_priv3( RIST_LOG_ERROR, "libevsocket, evsocket_loop: poll returned %d, n_events = %d, error = %d\n",
+diff --git a/src/rist-common.c b/src/rist-common.c
+index 00fc1e1..f42e448 100755
+--- a/src/rist-common.c
++++ b/src/rist-common.c
+@@ -2336,11 +2336,11 @@ static void rist_peer_recv_wrap(struct evsocket_ctx *evctx, int fd, short revent
+ 			buffer_offset = RIST_GRE_PROTOCOL_REDUCED_SIZE;
+ 
+ 		if (peer->address_family == AF_INET6) {
+-			recv_bufsize = recvfrom(peer->sd, (char*)recv_buf + buffer_offset, RIST_MAX_PACKET_SIZE, MSG_DONTWAIT, (struct sockaddr *) &addr6, &addrlen);
++			recv_bufsize = udpsocket_recvfrom(peer->sd, (char*)recv_buf + buffer_offset, RIST_MAX_PACKET_SIZE, MSG_DONTWAIT, (struct sockaddr *) &addr6, &addrlen);
+ 			family = AF_INET6;
+ 			addr = (struct sockaddr *) &addr6;
+ 		} else {
+-			recv_bufsize = recvfrom(peer->sd, (char *)recv_buf + buffer_offset, RIST_MAX_PACKET_SIZE, MSG_DONTWAIT, (struct sockaddr *)&addr4, &addrlen);
++			recv_bufsize = udpsocket_recvfrom(peer->sd, (char *)recv_buf + buffer_offset, RIST_MAX_PACKET_SIZE, MSG_DONTWAIT, (struct sockaddr *)&addr4, &addrlen);
+ 			addr = (struct sockaddr *) &addr4;
+ 		}
+ #ifndef _WIN32
+diff --git a/src/udp.c b/src/udp.c
+index 7ba3a8c..eb68743 100755
+--- a/src/udp.c
++++ b/src/udp.c
+@@ -294,7 +294,7 @@ size_t rist_send_seq_rtcp(struct rist_peer *p, uint16_t seq_rtp, uint8_t payload
+ 		}
+ 	}
+ 
+-	ret = sendto(p->sd,(const char*)data, len, 0, &(p->u.address), p->address_len);
++	ret = udp_sendto(p->sd,(const char*)data, len, 0, &(p->u.address), p->address_len);
+ 
+ out:
+ 	if (RIST_UNLIKELY(ret <= 0)) {
+@@ -521,7 +521,7 @@ void rist_create_socket(struct rist_peer *peer)
+ 			peer->multicast = IN6_IS_ADDR_MULTICAST(&addrv6->sin6_addr);
+ 		}
+ 		if (peer->multicast) {
+-			rist_log_priv(get_cctx(peer), RIST_LOG_INFO, "Peer configured for multicast");
++			rist_log_priv(get_cctx(peer), RIST_LOG_INFO, "Peer configured for multicast\n");
+ 		}
+ 		// We use sendto ... so, no need to connect directly here
+ 		peer->sd = udpsocket_open(peer->address_family);
+@@ -556,8 +556,9 @@ void rist_create_socket(struct rist_peer *peer)
+ 	if (peer->cname[0] == 0)
+ 		rist_populate_cname(peer);
+ 	rist_log_priv(get_cctx(peer), RIST_LOG_INFO, "Peer cname is %s\n", peer->cname);
++
+ #ifndef _WIN32
+-	if (fcntl(peer->sd, F_SETFD, FD_CLOEXEC) == -1) {
++	if (udp_fcntl(peer->sd, F_SETFD, FD_CLOEXEC) == -1) {
+ 		udpsocket_close(peer->sd);
+ 		rist_log_priv(get_cctx(peer), RIST_LOG_ERROR, "Could not set close-on-exec\n");
+ 		peer->sd = -1;
+diff --git a/src/udpsocket.c b/src/udpsocket.c
+index 20ef047..959f13a 100644
+--- a/src/udpsocket.c
++++ b/src/udpsocket.c
+@@ -14,11 +14,9 @@
+ #endif
+ #endif
+ 
+-/* Private functions */
+-static const int yes = 1; // no = 0;
++int udp_setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
+ 
+ /* Public API */
+-
+ int udpsocket_resolve_host(const char *host, uint16_t port, struct sockaddr *addr)
+ {
+ 	struct sockaddr_in *a4 = (struct sockaddr_in *)addr;
+@@ -53,138 +51,6 @@ int udpsocket_resolve_host(const char *host, uint16_t port, struct sockaddr *add
+ 	return 0;
+ }
+ 
+-int udpsocket_open(uint16_t af)
+-{
+-	int sd = socket(af, SOCK_DGRAM, 0);
+-	if (sd < 0) {
+-#ifdef _WIN32
+-		sd = -1 * WSAGetLastError();
+-#endif
+-	}
+-	return sd;
+-}
+-
+-int udpsocket_set_optimal_buffer_size(int sd)
+-{
+-	uint32_t bufsize = UDPSOCKET_SOCK_BUFSIZE;
+-	uint32_t current_recvbuf = udpsocket_get_buffer_size(sd);
+-	if (current_recvbuf < bufsize){
+-		setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, sizeof(uint32_t));
+-		current_recvbuf = udpsocket_get_buffer_size(sd);
+-#if defined(SO_RCVBUFFORCE)
+-		if (current_recvbuf < bufsize){
+-			setsockopt(sd, SOL_SOCKET, SO_RCVBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
+-			current_recvbuf = udpsocket_get_buffer_size(sd);
+-		}
+-#endif
+-	}
+-	if (current_recvbuf < bufsize){
+-		// Settle for a smaller size
+-		bufsize = UDPSOCKET_SOCK_BUFSIZE/5;
+-		setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, sizeof(uint32_t));
+-		current_recvbuf = udpsocket_get_buffer_size(sd);
+-#if defined(SO_RCVBUFFORCE)
+-		if (current_recvbuf < bufsize){
+-			setsockopt(sd, SOL_SOCKET, SO_RCVBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
+-			current_recvbuf = udpsocket_get_buffer_size(sd);
+-		}
+-#endif
+-	}
+-	if (current_recvbuf < bufsize){
+-		rist_log_priv3( RIST_LOG_ERROR, "Your UDP receive buffer is set < 200 kbytes (%"PRIu32") and the kernel denied our request for an increase. It's recommended to set your net.core.rmem_max setting to at least 200 kbyte for best results.", current_recvbuf);
+-		return -1;
+-	}
+-	return 0;
+-}
+-
+-int udpsocket_set_optimal_buffer_send_size(int sd)
+-{
+-	uint32_t bufsize = UDPSOCKET_SOCK_BUFSIZE;
+-	uint32_t current_sendbuf = udpsocket_get_buffer_send_size(sd);
+-	if (current_sendbuf < bufsize){
+-		setsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, sizeof(uint32_t));
+-		current_sendbuf = udpsocket_get_buffer_send_size(sd);
+-#if defined(SO_SNDBUFFORCE)
+-		if (current_sendbuf < bufsize){
+-			setsockopt(sd, SOL_SOCKET, SO_SNDBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
+-			current_sendbuf = udpsocket_get_buffer_send_size(sd);
+-		}
+-#endif
+-	}
+-	if (current_sendbuf < bufsize){
+-		// Settle for a smaller size
+-		bufsize = UDPSOCKET_SOCK_BUFSIZE/5;
+-		setsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, sizeof(uint32_t));
+-		current_sendbuf = udpsocket_get_buffer_send_size(sd);
+-#if defined(SO_SNDBUFFORCE)
+-		if (current_sendbuf < bufsize){
+-			setsockopt(sd, SOL_SOCKET, SO_SNDBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
+-			current_sendbuf = udpsocket_get_buffer_send_size(sd);
+-		}
+-#endif
+-	}
+-	if (current_sendbuf < bufsize){
+-		rist_log_priv3( RIST_LOG_ERROR, "Your UDP send buffer is set < 200 kbytes (%"PRIu32") and the kernel denied our request for an increase. It's recommended to set your net.core.rmem_max setting to at least 200 kbyte for best results.", current_sendbuf);
+-		return -1;
+-	}
+-	return 0;
+-}
+-
+-int udpsocket_set_buffer_size(int sd, uint32_t bufsize)
+-{
+-	if (setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, sizeof(uint32_t)) < 0)
+-		return -1;
+-	return 0;
+-}
+-
+-int udpsocket_set_buffer_send_size(int sd, uint32_t bufsize)
+-{
+-	if (setsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, sizeof(uint32_t)) < 0)
+-		return -1;
+-	return 0;
+-}
+-
+-uint32_t udpsocket_get_buffer_size(int sd)
+-{
+-	uint32_t bufsize;
+-	socklen_t val_size = sizeof(uint32_t);
+-	if (getsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, &val_size) < 0)
+-		return 0;
+-	return bufsize;
+-}
+-
+-uint32_t udpsocket_get_buffer_send_size(int sd)
+-{
+-	uint32_t bufsize;
+-	socklen_t val_size = sizeof(uint32_t);
+-	if (getsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, &val_size) < 0)
+-		return 0;
+-	return bufsize;
+-}
+-
+-int udpsocket_set_mcast_iface(int sd, const char *mciface, uint16_t family)
+-{
+-#ifndef _WIN32
+-	int scope = if_nametoindex(mciface);
+-#else
+-	int scope = atoi(mciface);
+-#endif
+-	if (scope == 0)
+-		return -1;
+-#ifdef _WIN32
+-	RIST_MARK_UNUSED(family);
+-	return setsockopt(sd, SOL_IP, IP_MULTICAST_IF, (char *)&scope, sizeof(scope));
+-#else
+-	if (family == AF_INET6) {
+-		return setsockopt(sd, SOL_IPV6, IPV6_MULTICAST_IF, &scope, sizeof(scope));
+-	} else {
+-		struct ip_mreqn req = { .imr_ifindex = scope };
+-		return setsockopt(sd, SOL_IP, IP_MULTICAST_IF, &req, sizeof(req));
+-	}
+-	return -1;
+-#endif
+-}
+-
+ bool is_ip_address(const char *ipaddress, int family) {
+ 	struct sockaddr_in sa;
+ 	int result = inet_pton(family, ipaddress, &(sa.sin_addr));
+@@ -220,7 +86,7 @@ int udpsocket_join_mcast_group(int sd, const char* miface, struct sockaddr* sa,
+ 		gr.gr_interface = ifindex;
+ 		memcpy(&gr.gr_group, mcast_v4, sizeof(*mcast_v4));
+ 		rist_log_priv3(RIST_LOG_INFO, "Joining multicast address: %s with %s\n", mcastaddress, miface);
+-		if (setsockopt(sd, SOL_IP, MCAST_JOIN_GROUP, (const char *)&gr, sizeof(gr)) == 0) {
++		if (udp_setsockopt(sd, SOL_IP, MCAST_JOIN_GROUP, (const char *)&gr, sizeof(gr)) == 0) {
+ 			return 0;
+ 		}
+ 	}
+@@ -230,7 +96,7 @@ int udpsocket_join_mcast_group(int sd, const char* miface, struct sockaddr* sa,
+ 	struct ip_mreq group;
+ 	group.imr_multiaddr.s_addr = mcast_v4->sin_addr.s_addr;
+ 	group.imr_interface.s_addr = src_addr;
+-	if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *)&group, sizeof(group)) < 0) {
++	if (udp_setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *)&group, sizeof(group)) < 0) {
+ 		rist_log_priv3( RIST_LOG_ERROR, "Failed to join multicast group\n");
+ 		goto fail;
+ 	}
+@@ -240,6 +106,204 @@ fail:
+ 	return -1;
+ }
+ 
++#ifdef RIST_HAS_MTL
++int udpsocket_bind(int sd, const char *host, uint16_t port)
++{
++	struct sockaddr_in6 raw;
++	uint16_t addrlen;
++
++	if (udpsocket_resolve_host(host, port, (struct sockaddr *)&raw) < 0) {
++		rist_log_priv3(RIST_LOG_ERROR, "%s, resolve host fail\n", __func__);
++		return -EIO;
++	}
++	if (raw.sin6_family == AF_INET6) {
++		addrlen = sizeof(struct sockaddr_in6);
++	} else {
++		addrlen = sizeof(struct sockaddr_in);
++	}
++
++	int ret = mufd_bind(sd, (const struct sockaddr *)&raw, addrlen);
++	if (ret < 0) {
++		return ret;
++	}
++
++	rist_log_priv3(RIST_LOG_INFO, "%s, sd %p, %s:%u\n", __func__, sd, host, port);
++	return 0;
++}
++
++int udpsocket_open_bind(const char *host, uint16_t port, const char *mciface)
++{
++	int sd;
++	struct sockaddr_in6 raw;
++	uint16_t addrlen;
++
++	if (udpsocket_resolve_host(host, port, (struct sockaddr *)&raw) < 0) {
++		rist_log_priv3(RIST_LOG_ERROR, "%s, resolve host fail\n", __func__);
++		return -EIO;
++	}
++	int is_multicast = 0;
++	if (raw.sin6_family == AF_INET6) {
++		addrlen = sizeof(struct sockaddr_in6);
++		is_multicast = IN6_IS_ADDR_MULTICAST(&raw.sin6_addr);
++	} else {
++		struct sockaddr_in *tmp = (struct sockaddr_in*)&raw;
++		addrlen = sizeof(struct sockaddr_in);
++		is_multicast = IN_MULTICAST(ntohl(tmp->sin_addr.s_addr));
++	}
++
++	sd = udpsocket_open(raw.sin6_family);
++	if (sd < 0) {
++		rist_log_priv3(RIST_LOG_ERROR, "%s, open socket fail\n", __func__);
++		return sd;
++	}
++
++	int ret = mufd_bind(sd, (const struct sockaddr *)&raw, addrlen);
++	if (ret < 0) {
++		rist_log_priv3(RIST_LOG_ERROR, "%s, bind fail\n", __func__);
++		udpsocket_close(sd);
++		return ret;
++	}
++
++	if (is_multicast) {
++		if (udpsocket_join_mcast_group(sd, mciface, (struct sockaddr *)&raw, raw.sin6_family) != 0) {
++			rist_log_priv3( RIST_LOG_ERROR, "Could not join multicast group: %s on %s\n", host, mciface);
++			return -1;
++		}
++	}
++
++	rist_log_priv3(RIST_LOG_INFO, "%s, sd %p, %s:%u %s\n", __func__, sd, host, port, mciface);
++	return sd;
++}
++
++int udpsocket_open(uint16_t af)
++{
++	return mufd_socket(af, SOCK_DGRAM, 0);
++}
++
++int udpsocket_open_connect(const char *host, uint16_t port, const char *mciface)
++{
++	RIST_MARK_UNUSED(host);
++	RIST_MARK_UNUSED(port);
++	RIST_MARK_UNUSED(mciface);
++	rist_log_priv3(RIST_LOG_ERROR, "%s, not implement\n", __func__);
++	return -EIO;
++}
++
++int udpsocket_close(int sd)
++{
++	return mufd_close(sd);
++}
++
++int udpsocket_send(int sd, const void *buf, size_t size)
++{
++	RIST_MARK_UNUSED(sd);
++	RIST_MARK_UNUSED(buf);
++	RIST_MARK_UNUSED(size);
++	rist_log_priv3(RIST_LOG_ERROR, "%s, not implement\n", __func__);
++	return 0;
++}
++
++ssize_t udp_sendto(int sockfd, const void *buf, size_t len, int flags,
++                      const struct sockaddr *dest_addr, socklen_t addrlen) {
++#if 0
++	struct sockaddr_in* saddr = (struct sockaddr_in*)dest_addr;
++	if (len < 500) {
++	rist_log_priv3(RIST_LOG_DEBUG, "%s, sockfd %d len %d port %u\n", __func__,
++		sockfd, (int)len, ntohs(saddr->sin_port));
++	}
++#endif
++	return mufd_sendto(sockfd, buf, len, flags, dest_addr, addrlen);
++}
++
++int udpsocket_recvfrom(int sd, void *buf, size_t size, int flags, struct sockaddr *addr, socklen_t *addr_len)
++{
++	int ret;
++	ret = mufd_recvfrom(sd, buf, size, flags, addr, addr_len);
++#if 0
++	struct sockaddr_in* saddr = (struct sockaddr_in*)addr;
++	if (ret < 500) {
++	rist_log_priv3(RIST_LOG_INFO, "%s, sd %d size %d port %u ret %d\n", __func__,
++		sd, (int)size, ntohs(saddr->sin_port), ret);
++	}
++#endif
++	return ret;
++}
++
++int udpsocket_set_nonblocking(int sd)
++{
++	RIST_MARK_UNUSED(sd);
++	rist_log_priv3(RIST_LOG_INFO, "%s, not implement\n", __func__);
++	return 0;
++}
++
++int udpsocket_send_nonblocking(int sd, const void *buf, size_t size)
++{
++	return udpsocket_send(sd, buf, size);
++}
++
++int udp_poll(struct pollfd* fds, nfds_t nfds, int timeout)
++{
++#if 0
++  for (nfds_t i = 0; i < nfds; i++) {
++    rist_log_priv3(RIST_LOG_INFO, "%s, fd %d\n", __func__, fds[i].fd);
++  }
++#endif
++
++  return mufd_poll(fds, nfds, timeout);
++}
++
++int udp_getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen)
++{
++	return mufd_getsockopt(sockfd, level, optname, optval, optlen);
++}
++
++int udp_setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)
++{
++	return mufd_setsockopt(sockfd, level, optname, optval, optlen);
++}
++
++int udp_fcntl(int fd, int cmd, long arg)
++{
++	return mufd_fcntl(fd, cmd, arg);
++}
++#else
++/* Private functions */
++static const int yes = 1; // no = 0;
++
++int udpsocket_open(uint16_t af)
++{
++	int sd = socket(af, SOCK_DGRAM, 0);
++	if (sd < 0) {
++#ifdef _WIN32
++		sd = -1 * WSAGetLastError();
++#endif
++	}
++	return sd;
++}
++
++int udpsocket_set_mcast_iface(int sd, const char *mciface, uint16_t family)
++{
++#ifndef _WIN32
++	int scope = if_nametoindex(mciface);
++#else
++	int scope = atoi(mciface);
++#endif
++	if (scope == 0)
++		return -1;
++#ifdef _WIN32
++	RIST_MARK_UNUSED(family);
++	return udp_setsockopt(sd, SOL_IP, IP_MULTICAST_IF, (char *)&scope, sizeof(scope));
++#else
++	if (family == AF_INET6) {
++		return udp_setsockopt(sd, SOL_IPV6, IPV6_MULTICAST_IF, &scope, sizeof(scope));
++	} else {
++		struct ip_mreqn req = { .imr_ifindex = scope };
++		return udp_setsockopt(sd, SOL_IP, IP_MULTICAST_IF, &req, sizeof(req));
++	}
++	return -1;
++#endif
++}
++
+ int udpsocket_open_connect(const char *host, uint16_t port, const char *mciface)
+ {
+ 	int sd;
+@@ -266,11 +330,11 @@ int udpsocket_open_connect(const char *host, uint16_t port, const char *mciface)
+ 		ttlcmd = IP_MULTICAST_TTL;
+ 	}
+ 
+-	if (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&yes, sizeof(int)) < 0) {
++	if (udp_setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&yes, sizeof(int)) < 0) {
+ 		/* Non-critical error */
+ 		rist_log_priv3( RIST_LOG_ERROR,"Cannot set SO_REUSEADDR: %s\n", strerror(errno));
+ 	}
+-	if (setsockopt(sd, proto, ttlcmd, (char *)&ttl, sizeof(ttl)) < 0) {
++	if (udp_setsockopt(sd, proto, ttlcmd, (char *)&ttl, sizeof(ttl)) < 0) {
+ 		/* Non-critical error */
+ 		rist_log_priv3( RIST_LOG_ERROR,"Cannot set socket MAX HOPS: %s\n", strerror(errno));
+ 	}
+@@ -308,7 +372,7 @@ int udpsocket_open_bind(const char *host, uint16_t port, const char *mciface)
+ 		addrlen = sizeof(struct sockaddr_in);
+ 		is_multicast = IN_MULTICAST(ntohl(tmp->sin_addr.s_addr));
+ 	}
+-	if (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&yes, sizeof(int)) < 0) {
++	if (udp_setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&yes, sizeof(int)) < 0) {
+ 		/* Non-critical error */
+ 		rist_log_priv3( RIST_LOG_ERROR, "Cannot set SO_REUSEADDR: %s\n", strerror(errno));
+ 	}
+@@ -372,6 +436,19 @@ int udpsocket_sendto(int sd, const void *buf, size_t size, const char *host, uin
+ 	return (int)sendto(sd, buf, size, 0, (struct sockaddr *)(&raw), addrlen);
+ }
+ 
++ssize_t udp_sendto(int sockfd, const void *buf, size_t len, int flags,
++                      const struct sockaddr *dest_addr, socklen_t addrlen) {
++#if 0
++	struct sockaddr_in* saddr = (struct sockaddr_in*)dest_addr;
++
++	if (len < 500) {
++	rist_log_priv3(RIST_LOG_DEBUG, "%s, sockfd %p len %d port %u\n", __func__,
++		sockfd, (int)len, ntohs(saddr->sin_port));
++	}
++#endif
++	return sendto(sockfd, buf, len, flags, dest_addr, addrlen);
++}
++
+ int udpsocket_recv(int sd, void *buf, size_t size)
+ {
+ 	return (int)recv(sd, buf, size, 0);
+@@ -379,7 +456,16 @@ int udpsocket_recv(int sd, void *buf, size_t size)
+ 
+ int udpsocket_recvfrom(int sd, void *buf, size_t size, int flags, struct sockaddr *addr, socklen_t *addr_len)
+ {
+-	return (int)recvfrom(sd, buf, size, flags, addr, addr_len);
++	int ret;
++	ret = recvfrom(sd, buf, size, flags, addr, addr_len);
++#if 0
++	struct sockaddr_in* saddr = (struct sockaddr_in*)addr;
++	if (ret < 500) {
++	rist_log_priv3(RIST_LOG_INFO, "%s, sd %p size %d port %u ret %d\n", __func__,
++		sd, (int)size, ntohs(saddr->sin_port), ret);
++	}
++#endif
++	return ret;
+ }
+ 
+ int udpsocket_close(int sd)
+@@ -391,6 +477,125 @@ int udpsocket_close(int sd)
+ #endif
+ }
+ 
++int udp_poll(struct pollfd* fds, nfds_t nfds, int timeout)
++{
++  return poll(fds, nfds, timeout);
++}
++
++int udp_getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen)
++{
++	return getsockopt(sockfd, level, optname, optval, optlen);
++}
++
++int udp_setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)
++{
++	return setsockopt(sockfd, level, optname, optval, optlen);
++}
++
++int udp_fcntl(int fd, int cmd, long arg)
++{
++	return fcntl(fd, cmd, arg);
++}
++#endif
++
++int udpsocket_set_optimal_buffer_send_size(int sd)
++{
++	uint32_t bufsize = UDPSOCKET_SOCK_BUFSIZE;
++	uint32_t current_sendbuf = udpsocket_get_buffer_send_size(sd);
++	if (current_sendbuf < bufsize){
++		udp_setsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, sizeof(uint32_t));
++		current_sendbuf = udpsocket_get_buffer_send_size(sd);
++#if defined(SO_SNDBUFFORCE)
++		if (current_sendbuf < bufsize){
++			udp_setsockopt(sd, SOL_SOCKET, SO_SNDBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
++			current_sendbuf = udpsocket_get_buffer_send_size(sd);
++		}
++#endif
++	}
++	if (current_sendbuf < bufsize){
++		// Settle for a smaller size
++		bufsize = UDPSOCKET_SOCK_BUFSIZE/5;
++		udp_setsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, sizeof(uint32_t));
++		current_sendbuf = udpsocket_get_buffer_send_size(sd);
++#if defined(SO_SNDBUFFORCE)
++		if (current_sendbuf < bufsize){
++			udp_setsockopt(sd, SOL_SOCKET, SO_SNDBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
++			current_sendbuf = udpsocket_get_buffer_send_size(sd);
++		}
++#endif
++	}
++	if (current_sendbuf < bufsize){
++		rist_log_priv3( RIST_LOG_INFO, "Your UDP send buffer is set < 200 kbytes (%"PRIu32") and the kernel denied our request for an increase. It's recommended to set your net.core.rmem_max setting to at least 200 kbyte for best results.", current_sendbuf);
++		return -1;
++	}
++	return 0;
++}
++
++int udpsocket_set_buffer_size(int sd, uint32_t bufsize)
++{
++	if (udp_setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, sizeof(uint32_t)) < 0)
++		return -1;
++	return 0;
++}
++
++int udpsocket_set_buffer_send_size(int sd, uint32_t bufsize)
++{
++	if (udp_setsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, sizeof(uint32_t)) < 0)
++		return -1;
++	return 0;
++}
++
++uint32_t udpsocket_get_buffer_size(int sd)
++{
++	uint32_t bufsize;
++	socklen_t val_size = sizeof(uint32_t);
++	if (udp_getsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, &val_size) < 0)
++		return 0;
++	return bufsize;
++}
++
++uint32_t udpsocket_get_buffer_send_size(int sd)
++{
++	uint32_t bufsize;
++	socklen_t val_size = sizeof(uint32_t);
++	if (udp_getsockopt(sd, SOL_SOCKET, SO_SNDBUF, (char *)&bufsize, &val_size) < 0)
++		return 0;
++	return bufsize;
++}
++
++int udpsocket_set_optimal_buffer_size(int sd)
++{
++	uint32_t bufsize = UDPSOCKET_SOCK_BUFSIZE;
++	uint32_t current_recvbuf = udpsocket_get_buffer_size(sd);
++	if (current_recvbuf < bufsize){
++		udp_setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, sizeof(uint32_t));
++		current_recvbuf = udpsocket_get_buffer_size(sd);
++#if defined(SO_RCVBUFFORCE)
++		if (current_recvbuf < bufsize){
++			udp_setsockopt(sd, SOL_SOCKET, SO_RCVBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
++			current_recvbuf = udpsocket_get_buffer_size(sd);
++		}
++#endif
++	}
++	if (current_recvbuf < bufsize){
++		// Settle for a smaller size
++		bufsize = UDPSOCKET_SOCK_BUFSIZE/5;
++		udp_setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (char *)&bufsize, sizeof(uint32_t));
++		current_recvbuf = udpsocket_get_buffer_size(sd);
++#if defined(SO_RCVBUFFORCE)
++		if (current_recvbuf < bufsize){
++			udp_setsockopt(sd, SOL_SOCKET, SO_RCVBUFFORCE, (char *)&bufsize, sizeof(uint32_t));
++			current_recvbuf = udpsocket_get_buffer_size(sd);
++		}
++#endif
++	}
++	if (current_recvbuf < bufsize){
++		rist_log_priv3( RIST_LOG_INFO, "Your UDP receive buffer is set < 200 kbytes (%"PRIu32") and the kernel denied our request for an increase. It's recommended to set your net.core.rmem_max setting to at least 200 kbyte for best results.", current_recvbuf);
++		return -1;
++	}
++	return 0;
++}
++
+ int udpsocket_parse_url_parameters(const char *url, udpsocket_url_param_t *params, int max_params,
+ 	uint32_t *clean_url_len)
+ {
+-- 
+2.34.1
+
diff --git a/0002-test-add-seprate-send-and-recv-with-multi-session-su.patch b/0002-test-add-seprate-send-and-recv-with-multi-session-su.patch
new file mode 100644
index 0000000..ea2ba91
--- /dev/null
+++ b/0002-test-add-seprate-send-and-recv-with-multi-session-su.patch
@@ -0,0 +1,778 @@
+From 741fafe6c7fb2bf3e5cfb1fe9c1413fd453f08a1 Mon Sep 17 00:00:00 2001
+From: Frank Du <frank.du@intel.com>
+Date: Wed, 22 Feb 2023 10:06:28 +0800
+Subject: [PATCH 2/3] test: add seprate send and recv with multi session
+ support
+
+usage:
+./build/test/rist/test_send --sleep_us 50 --sleep_step 1 --sessions_cnt
+2 --dip 127.0.0.1
+./build/test/rist/test_receive --sessions_cnt 2 --sip 127.0.0.1
+
+MUFD_CFG=test/rist/ufd_send.json ./build/test/rist/test_send --sleep_us
+50 --sleep_step 1 --sessions_cnt 2 --dip 192.168.85.80
+MUFD_CFG=test/rist/ufd_receive.json ./build/test/rist/test_receive
+--sessions_cnt 2 --sip 192.168.85.60
+
+Signed-off-by: Frank Du <frank.du@intel.com>
+---
+ test/rist/meson.build      |  19 +++
+ test/rist/test_receive.c   | 245 +++++++++++++++++++++++++++++++++++++
+ test/rist/test_send.c      | 236 +++++++++++++++++++++++++++++++++++
+ test/rist/test_util.c      | 108 ++++++++++++++++
+ test/rist/test_util.h      |  65 ++++++++++
+ test/rist/ufd_receive.json |  11 ++
+ test/rist/ufd_send.json    |  11 ++
+ 7 files changed, 695 insertions(+)
+ create mode 100644 test/rist/test_receive.c
+ create mode 100644 test/rist/test_send.c
+ create mode 100644 test/rist/test_util.c
+ create mode 100644 test/rist/test_util.h
+ create mode 100644 test/rist/ufd_receive.json
+ create mode 100644 test/rist/ufd_send.json
+
+diff --git a/test/rist/meson.build b/test/rist/meson.build
+index 101bd1a..a9bb907 100644
+--- a/test/rist/meson.build
++++ b/test/rist/meson.build
+@@ -40,6 +40,25 @@ test_send_receive = executable('test_send_receive',
+ 									stdatomic_dependency
+                                 ])
+ 
++test_send = executable('test_send',
++                                'test_send.c', 'test_util.c',
++                                extra_sources,
++                                include_directories: inc,
++                                link_with: librist,
++                                dependencies: [
++                                    threads,
++                                    stdatomic_dependency
++                                ])
++
++test_receive = executable('test_receive',
++                                'test_receive.c', 'test_util.c',
++                                extra_sources,
++                                include_directories: inc,
++                                link_with: librist,
++                                dependencies: [
++                                    threads,
++                                    stdatomic_dependency
++                                ])
+ 
+ if comockatests
+     test('rist test', risttest)
+diff --git a/test/rist/test_receive.c b/test/rist/test_receive.c
+new file mode 100644
+index 0000000..e9f9412
+--- /dev/null
++++ b/test/rist/test_receive.c
+@@ -0,0 +1,245 @@
++/* SPDX-License-Identifier: BSD-3-Clause
++ * Copyright(c) 2023 Intel Corporation
++ */
++
++#include "librist/librist.h"
++#include "rist-private.h"
++
++#include "test_util.h"
++
++struct recv_session_ctx {
++  struct test_ctx *parent;
++  int idx;
++  bool exit;
++  char url[64 * 2]; /* rist://@192.168.85.61:1234 */
++
++  struct rist_logging_settings *r_log;
++  struct rist_ctx *r_ctx;
++  struct rist_peer_config *r_peer_config;
++  struct rist_peer *r_peer;
++
++  pthread_t worker;
++
++  int stat_recv_cnt;
++  int stat_recv_wrong_cnt;
++  int stat_recv_size;
++};
++
++static int recv_log_cb(void *arg, int level, const char *msg) {
++  struct recv_session_ctx *s = arg;
++  int idx = s->idx;
++
++  if (level > RIST_LOG_ERROR)
++    info("recver(%d): %s", idx, msg);
++  if (level <= RIST_LOG_ERROR) {
++    err("recver(%d), error: %s", idx, msg);
++    s->exit = true;
++  }
++  return 0;
++}
++
++static int recver_uinit(struct recv_session_ctx *s) {
++  int idx = s->idx;
++
++  dbg("%s(%d), start\n", __func__, idx);
++  if (s->r_peer) {
++    dbg("%s(%d), rist_peer_destroy\n", __func__, idx);
++    // rist_peer_destroy(s->r_ctx, s->r_peer);
++    s->r_peer = NULL;
++  }
++  if (s->r_ctx) {
++    info("%s(%d), rist_destroy\n", __func__, idx);
++    rist_destroy(s->r_ctx);
++    s->r_ctx = NULL;
++  }
++  if (s->r_peer_config) {
++    free(s->r_peer_config);
++    s->r_peer_config = NULL;
++  }
++  if (s->r_log) {
++    free(s->r_log);
++    s->r_log = NULL;
++  }
++  info("%s(%d), succ\n", __func__, idx);
++  return 0;
++}
++
++static int recver_init(struct test_ctx *ctx, struct recv_session_ctx *s) {
++  struct rist_ctx *r_ctx = NULL;
++  struct rist_logging_settings *log = NULL;
++  int idx = s->idx;
++  int ret;
++
++  ret = rist_logging_set(&log, RIST_LOG_INFO, recv_log_cb, s, NULL, stderr);
++  if (ret < 0) {
++    err("%s(%d), rist_logging_set fail %d\n", __func__, idx, ret);
++    recver_uinit(s);
++    return ret;
++  }
++  s->r_log = log;
++
++  ret = rist_receiver_create(&r_ctx, ctx->profile, log);
++  if (ret < 0) {
++    err("%s(%d), rist_recver_create fail %d\n", __func__, idx, ret);
++    recver_uinit(s);
++    return ret;
++  }
++  s->r_ctx = r_ctx;
++
++  rist_receiver_set_output_fifo_size(r_ctx, ctx->rx_fifo_size);
++
++  snprintf(s->url, sizeof(s->url), "rist://@%s:%d", ctx->dip,
++           ctx->udp_port + idx * 2);
++  struct rist_peer_config *peer_config = NULL;
++  ret = rist_parse_address2(s->url, &peer_config);
++  if (ret < 0) {
++    err("%s(%d), rist_parse_address2 fail %d\n", __func__, idx, ret);
++    recver_uinit(s);
++    return ret;
++  }
++  s->r_peer_config = peer_config;
++
++  struct rist_peer *peer;
++  ret = rist_peer_create(r_ctx, &peer, s->r_peer_config);
++  if (ret < 0) {
++    err("%s(%d), rist_peer_create fail %d\n", __func__, idx, ret);
++    recver_uinit(s);
++    return ret;
++  }
++  s->r_peer = peer;
++
++  ret = rist_start(r_ctx);
++  if (ret < 0) {
++    err("%s(%d), rist_start fail %d\n", __func__, idx, ret);
++    recver_uinit(s);
++    return ret;
++  }
++
++  return 0;
++}
++
++static double recver_status(struct recv_session_ctx *s) {
++  int idx = s->idx;
++  int recv_cnt = s->stat_recv_cnt;
++  int recv_sz = s->stat_recv_size;
++  double bps = (double)recv_sz * 8 / s->parent->stat_period_s;
++  double bps_g = bps / (1000 * 1000 * 1000);
++
++  info("%s(%d), Recv %d pkts(%f g/s), wrong %d\n", __func__, idx, recv_cnt,
++       bps_g, s->stat_recv_wrong_cnt);
++  s->stat_recv_cnt = 0;
++  s->stat_recv_size = 0;
++  s->stat_recv_wrong_cnt = 0;
++  return bps_g;
++}
++
++static PTHREAD_START_FUNC(recver_worker, arg) {
++  struct recv_session_ctx *s = arg;
++  int idx = s->idx;
++  struct test_ctx *parent = s->parent;
++  uint16_t recv_idx = 0; /* only 16bit seq idx in the rtp */
++  char buffer[1460] = {0};
++  struct rist_data_block *b = NULL;
++
++  info("%s(%d), start\n", __func__, idx);
++  while (!parent->exit && !s->exit) {
++    int read = rist_receiver_data_read2(s->r_ctx, &b, 5);
++    dbg("%s(%d), read %d\n", __func__, idx, read);
++    if (read <= 0)
++      continue;
++    sprintf(buffer, "DEADBEAF TEST PACKET #%u", recv_idx);
++    if (strcmp(buffer, b->payload)) {
++      dbg("%s(%d), wrong content at pkt %u, seq %lu\n", __func__, idx, recv_idx,
++          b->seq);
++      dbg("%s(%d), payload: %s\n", __func__, idx, (char *)b->payload);
++      recv_idx = b->seq;
++      s->stat_recv_wrong_cnt++;
++    }
++    recv_idx++;
++
++    s->stat_recv_cnt++;
++    s->stat_recv_size += b->payload_len;
++    rist_receiver_data_block_free2(&b);
++  }
++  info("%s(%d), stop\n", __func__, idx);
++
++  return 0;
++}
++
++int main(int argc, char *argv[]) {
++  struct test_ctx ctx;
++  int ret;
++
++  memset(&ctx, 0, sizeof(ctx));
++  ret = test_init_with_args(&ctx, argc, argv);
++  if (ret < 0)
++    return ret;
++  info("%s: sessions cnt %u\n", __func__, ctx.sessions);
++
++  int sessions = ctx.sessions;
++  struct recv_session_ctx **apps;
++  apps = test_zmalloc(sizeof(*apps) * sessions);
++  if (!apps) {
++    err("%s, apps malloc fail\n", __func__);
++    return -ENOMEM;
++  }
++
++  for (int i = 0; i < sessions; i++) {
++    struct recv_session_ctx *app = test_zmalloc(sizeof(*app));
++    if (!app) {
++      err("%s(%d), ctx malloc fail\n", __func__, i);
++      ret = -ENOMEM;
++      goto exit;
++    }
++    apps[i] = app;
++
++    app->idx = i;
++    app->worker = -1;
++    app->parent = &ctx;
++
++    ret = recver_init(&ctx, app);
++    if (ret < 0) {
++      err("%s(%d), recver_init fail %d\n", __func__, i, ret);
++      goto exit;
++    }
++
++    ret = pthread_create(&app->worker, NULL, recver_worker, app);
++    if (ret < 0) {
++      err("%s(%d), worker create fail %d\n", __func__, i, ret);
++      goto exit;
++    }
++  }
++
++  int time_s = 0;
++  while (!ctx.exit) {
++    sleep(1);
++    /* display server status every stat_period_s */
++    time_s++;
++    if ((time_s % ctx.stat_period_s) == 0) {
++      double bps_g = 0;
++      for (int i = 0; i < sessions; i++) {
++        bps_g += recver_status(apps[i]);
++      }
++      info("%s, total %f g/s\n", __func__, bps_g);
++    }
++  }
++
++  ret = 0;
++  info("%s, exit now\n", __func__);
++
++exit:
++  ctx.exit = true;
++  for (int i = 0; i < sessions; i++) {
++    struct recv_session_ctx *app = apps[i];
++    if (app) {
++      if (app->worker > 0) {
++        app->exit = true;
++        pthread_join(app->worker, NULL);
++      }
++      recver_uinit(app);
++      test_free(app);
++    }
++  }
++  test_free(apps);
++  return ret;
++}
+diff --git a/test/rist/test_send.c b/test/rist/test_send.c
+new file mode 100644
+index 0000000..5b89699
+--- /dev/null
++++ b/test/rist/test_send.c
+@@ -0,0 +1,236 @@
++/* SPDX-License-Identifier: BSD-3-Clause
++ * Copyright(c) 2023 Intel Corporation
++ */
++
++#include "librist/librist.h"
++#include "rist-private.h"
++
++#include "test_util.h"
++
++#define TX_UDP_LEN (1024 + 256)
++
++struct send_session_ctx {
++  struct test_ctx *parent;
++  int idx;
++  bool exit;
++  char url[64 * 2]; /* rist://192.168.85.61:1234 */
++
++  struct rist_logging_settings *r_log;
++  struct rist_ctx *r_ctx;
++  struct rist_peer_config *r_peer_config;
++  struct rist_peer *r_peer;
++
++  pthread_t worker;
++
++  int stat_send_cnt;
++};
++
++static int send_log_cb(void *arg, int level, const char *msg) {
++  struct send_session_ctx *s = arg;
++  int idx = s->idx;
++
++  if (level > RIST_LOG_ERROR)
++    info("sender(%d): %s", idx, msg);
++  if (level <= RIST_LOG_ERROR) {
++    err("sender(%d), error: %s", idx, msg);
++    s->exit = true;
++  }
++  return 0;
++}
++
++static int sender_uinit(struct send_session_ctx *s) {
++  if (s->r_peer) {
++    rist_peer_destroy(s->r_ctx, s->r_peer);
++    s->r_peer = NULL;
++  }
++  if (s->r_ctx) {
++    rist_destroy(s->r_ctx);
++    s->r_ctx = NULL;
++  }
++  if (s->r_peer_config) {
++    free(s->r_peer_config);
++    s->r_peer_config = NULL;
++  }
++  if (s->r_log) {
++    free(s->r_log);
++    s->r_log = NULL;
++  }
++  return 0;
++}
++
++static int sender_init(struct test_ctx *ctx, struct send_session_ctx *s) {
++  struct rist_ctx *r_ctx = NULL;
++  struct rist_logging_settings *log = NULL;
++  int idx = s->idx;
++  int ret;
++
++  ret = rist_logging_set(&log, RIST_LOG_INFO, send_log_cb, s, NULL, stderr);
++  if (ret < 0) {
++    err("%s(%d), rist_logging_set fail %d\n", __func__, idx, ret);
++    sender_uinit(s);
++    return ret;
++  }
++  s->r_log = log;
++
++  ret = rist_sender_create(&r_ctx, ctx->profile, 0, log);
++  if (ret < 0) {
++    err("%s(%d), rist_sender_create fail %d\n", __func__, idx, ret);
++    sender_uinit(s);
++    return ret;
++  }
++  s->r_ctx = r_ctx;
++
++  snprintf(s->url, sizeof(s->url), "rist://%s:%d", ctx->dip,
++           ctx->udp_port + idx * 2);
++  struct rist_peer_config *peer_config = NULL;
++  ret = rist_parse_address2(s->url, &peer_config);
++  if (ret < 0) {
++    err("%s(%d), rist_parse_address2 fail %d\n", __func__, idx, ret);
++    sender_uinit(s);
++    return ret;
++  }
++  s->r_peer_config = peer_config;
++
++  struct rist_peer *peer;
++  ret = rist_peer_create(r_ctx, &peer, s->r_peer_config);
++  if (ret < 0) {
++    err("%s(%d), rist_peer_create fail %d\n", __func__, idx, ret);
++    sender_uinit(s);
++    return ret;
++  }
++  s->r_peer = peer;
++
++  ret = rist_start(r_ctx);
++  if (ret < 0) {
++    err("%s(%d), rist_start fail %d\n", __func__, idx, ret);
++    sender_uinit(s);
++    return ret;
++  }
++
++  return 0;
++}
++
++static double sender_status(struct send_session_ctx *s) {
++  int idx = s->idx;
++  int send_cnt = s->stat_send_cnt;
++  double bps = (double)send_cnt * TX_UDP_LEN * 8 / s->parent->stat_period_s;
++  double bps_g = bps / (1000 * 1000 * 1000);
++
++  info("%s(%d), Send %d pkts(%f g/s)\n", __func__, idx, send_cnt, bps_g);
++  s->stat_send_cnt = 0;
++  return bps_g;
++}
++
++static PTHREAD_START_FUNC(sender_worker, arg) {
++  struct send_session_ctx *s = arg;
++  int idx = s->idx;
++  struct test_ctx *parent = s->parent;
++  uint16_t send_idx = 0;
++  char buffer[TX_UDP_LEN] = {0};
++  struct rist_data_block data = {0};
++
++  info("%s(%d), start\n", __func__, idx);
++  while (!parent->exit && !s->exit) {
++    sprintf(buffer, "DEADBEAF TEST PACKET #%u", send_idx);
++    data.payload = &buffer;
++    data.payload_len = sizeof(buffer);
++    int ret = rist_sender_data_write(s->r_ctx, &data);
++    if (ret < 0 || ret != (int)data.payload_len) {
++      err("%s(%d), rist_sender_data_write fail %d\n", __func__, idx, ret);
++      break;
++    }
++
++    send_idx++;
++    s->stat_send_cnt++;
++    if (parent->sleep_us) {
++      if (parent->sleep_step > 1) {
++        if ((send_idx % parent->sleep_step) == 0) {
++          usleep(parent->sleep_us);
++        }
++      } else {
++        usleep(parent->sleep_us);
++      }
++    }
++  }
++  info("%s(%d), stop\n", __func__, idx);
++
++  return 0;
++}
++
++int main(int argc, char *argv[]) {
++  struct test_ctx ctx;
++  int ret;
++
++  memset(&ctx, 0, sizeof(ctx));
++  ret = test_init_with_args(&ctx, argc, argv);
++  if (ret < 0)
++    return ret;
++  info("%s: sessions cnt %u\n", __func__, ctx.sessions);
++
++  int sessions = ctx.sessions;
++  struct send_session_ctx **apps;
++  apps = test_zmalloc(sizeof(*apps) * sessions);
++  if (!apps) {
++    err("%s, apps malloc fail\n", __func__);
++    return -ENOMEM;
++  }
++
++  for (int i = 0; i < sessions; i++) {
++    struct send_session_ctx *app = test_zmalloc(sizeof(*app));
++    if (!app) {
++      err("%s(%d), ctx malloc fail\n", __func__, i);
++      ret = -ENOMEM;
++      goto exit;
++    }
++    apps[i] = app;
++
++    app->idx = i;
++    app->worker = -1;
++    app->parent = &ctx;
++
++    ret = sender_init(&ctx, app);
++    if (ret < 0) {
++      err("%s(%d), sender_init fail %d\n", __func__, i, ret);
++      goto exit;
++    }
++
++    ret = pthread_create(&app->worker, NULL, sender_worker, app);
++    if (ret < 0) {
++      err("%s(%d), worker create fail %d\n", __func__, i, ret);
++      goto exit;
++    }
++  }
++
++  int time_s = 0;
++  while (!ctx.exit) {
++    sleep(1);
++    /* display server status every stat_period_s */
++    time_s++;
++    if ((time_s % ctx.stat_period_s) == 0) {
++      double bps_g = 0;
++      for (int i = 0; i < sessions; i++) {
++        bps_g += sender_status(apps[i]);
++      }
++      info("%s, total %f g/s\n", __func__, bps_g);
++    }
++  }
++
++  ret = 0;
++  info("%s, exit now\n", __func__);
++
++exit:
++  ctx.exit = true;
++  for (int i = 0; i < sessions; i++) {
++    struct send_session_ctx *app = apps[i];
++    if (app) {
++      if (app->worker > 0) {
++        app->exit = true;
++        pthread_join(app->worker, NULL);
++      }
++      sender_uinit(app);
++      test_free(app);
++    }
++  }
++  test_free(apps);
++  return ret;
++}
+diff --git a/test/rist/test_util.c b/test/rist/test_util.c
+new file mode 100644
+index 0000000..f316d86
+--- /dev/null
++++ b/test/rist/test_util.c
+@@ -0,0 +1,108 @@
++/* SPDX-License-Identifier: BSD-3-Clause
++ * Copyright(c) 2023 Intel Corporation
++ */
++
++#include "test_util.h"
++
++#include <getopt.h>
++#include <signal.h>
++
++enum test_args_cmd {
++  TEST_ARG_UNKNOWN = 0,
++
++  TEST_ARG_PROFILE = 0x100, /* start from end of ascii */
++  TEST_ARG_SESSIONS_CNT,
++  TEST_ARG_SLEEP_US,
++  TEST_ARG_SLEEP_STEP,
++  TEST_ARG_RX_FIFO_SIZE,
++  TEST_ARG_DIP,
++  TEST_ARG_SIP,
++
++  TEST_ARG_MAX,
++};
++
++static struct option test_args_options[] = {
++    {"profile", required_argument, 0, TEST_ARG_PROFILE},
++    {"sessions_cnt", required_argument, 0, TEST_ARG_SESSIONS_CNT},
++    {"sleep_us", required_argument, 0, TEST_ARG_SLEEP_US},
++    {"sleep_step", required_argument, 0, TEST_ARG_SLEEP_STEP},
++    {"rx_fifo_size", required_argument, 0, TEST_ARG_RX_FIFO_SIZE},
++    {"dip", required_argument, 0, TEST_ARG_DIP},
++    {"sip", required_argument, 0, TEST_ARG_SIP},
++
++    {0, 0, 0, 0}};
++
++static int test_parse_args(struct test_ctx *ctx, int argc, char **argv) {
++  int cmd = -1, optIdx = 0;
++
++  while (1) {
++    cmd = getopt_long_only(argc, argv, "hv", test_args_options, &optIdx);
++    if (cmd == -1)
++      break;
++    dbg("%s, cmd %d %s\n", __func__, cmd, optarg);
++
++    switch (cmd) {
++    case TEST_ARG_PROFILE:
++      ctx->profile = atoi(optarg);
++      break;
++    case TEST_ARG_SESSIONS_CNT:
++      ctx->sessions = atoi(optarg);
++      break;
++    case TEST_ARG_SLEEP_US:
++      ctx->sleep_us = atoi(optarg);
++      break;
++    case TEST_ARG_SLEEP_STEP:
++      ctx->sleep_step = atoi(optarg);
++      break;
++    case TEST_ARG_RX_FIFO_SIZE:
++      ctx->rx_fifo_size = atoi(optarg);
++      break;
++    case TEST_ARG_DIP:
++      strncpy(ctx->dip, optarg, sizeof(ctx->dip));
++      break;
++    case TEST_ARG_SIP:
++      strncpy(ctx->sip, optarg, sizeof(ctx->dip));
++      break;
++    case '?':
++      break;
++    default:
++      break;
++    }
++  };
++
++  return 0;
++}
++
++static struct test_ctx *g_test_ctx;
++static void test_sig_handler(int signo) {
++  struct test_ctx *ctx = g_test_ctx;
++  info("%s, signal %d\n", __func__, signo);
++
++  switch (signo) {
++  case SIGINT: /* Interrupt from keyboard */
++    ctx->exit = true;
++    break;
++  }
++
++  return;
++}
++
++int test_init_with_args(struct test_ctx *ctx, int argc, char **argv) {
++  g_test_ctx = ctx;
++  signal(SIGINT, test_sig_handler);
++
++  /* default value */
++  ctx->sessions = 1;
++  ctx->profile = 0; /* simple */
++  ctx->udp_port = 1234;
++  ctx->sleep_us = 100;
++  ctx->sleep_step = 1;
++  ctx->stat_period_s = 5;
++  ctx->rx_fifo_size = 1024 * 1024;
++  snprintf(ctx->dip, sizeof(ctx->dip), "%s", "127.0.0.1");
++  snprintf(ctx->sip, sizeof(ctx->dip), "%s", "127.0.0.1");
++
++  test_parse_args(ctx, argc, argv);
++
++  return 0;
++}
+diff --git a/test/rist/test_util.h b/test/rist/test_util.h
+new file mode 100644
+index 0000000..7d50e27
+--- /dev/null
++++ b/test/rist/test_util.h
+@@ -0,0 +1,65 @@
++/* SPDX-License-Identifier: BSD-3-Clause
++ * Copyright(c) 2023 Intel Corporation
++ */
++
++#ifndef _TEST_UTIL_H_
++#define _TEST_UTIL_H_
++
++#include <inttypes.h>
++#include <stdbool.h>
++#include <stddef.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <unistd.h>
++
++/* log define */
++#ifdef DEBUG
++#define dbg(...)                                                               \
++  do {                                                                         \
++    printf(__VA_ARGS__);                                                       \
++  } while (0)
++#else
++#define dbg(...)                                                               \
++  do {                                                                         \
++  } while (0)
++#endif
++#define info(...)                                                              \
++  do {                                                                         \
++    printf(__VA_ARGS__);                                                       \
++  } while (0)
++#define warn(...)                                                              \
++  do {                                                                         \
++    printf(__VA_ARGS__);                                                       \
++  } while (0)
++#define err(...)                                                               \
++  do {                                                                         \
++    printf(__VA_ARGS__);                                                       \
++  } while (0)
++
++struct test_ctx {
++  int profile;
++  int sessions; /* number of sessions */
++  int udp_port;
++  int sleep_us;
++  int sleep_step;
++  int stat_period_s;
++  int rx_fifo_size;
++  char dip[64]; /* dst ip for tx */
++  char sip[64]; /* source ip for rx */
++
++  bool exit;
++};
++
++int test_init_with_args(struct test_ctx *ctx, int argc, char **argv);
++
++static inline void *test_zmalloc(size_t sz) {
++  void *p = malloc(sz);
++  if (p)
++    memset(p, 0x0, sz);
++  return p;
++}
++
++static inline void test_free(void *p) { free(p); }
++
++#endif
+diff --git a/test/rist/ufd_receive.json b/test/rist/ufd_receive.json
+new file mode 100644
+index 0000000..685919a
+--- /dev/null
++++ b/test/rist/ufd_receive.json
+@@ -0,0 +1,11 @@
++{
++    "nb_udp_sockets" : "64",
++    "nb_nic_queues" : "64",
++    "nic_queue_rate_limit_g": 10,
++    "interfaces": [
++        {
++            "port": "0000:af:01.0",
++            "ip": "192.168.85.80"
++        }
++    ],
++}
+diff --git a/test/rist/ufd_send.json b/test/rist/ufd_send.json
+new file mode 100644
+index 0000000..552d3b0
+--- /dev/null
++++ b/test/rist/ufd_send.json
+@@ -0,0 +1,11 @@
++{
++    "nb_udp_sockets" : "64",
++    "nb_nic_queues" : "64",
++    "nic_queue_rate_limit_g": 10,
++    "interfaces": [
++        {
++            "port": "0000:af:01.1",
++            "ip": "192.168.85.60"
++        }
++    ],
++}
+-- 
+2.34.1
+
diff --git a/0003-fix-kernel-path.patch b/0003-fix-kernel-path.patch
new file mode 100644
index 0000000..228e627
--- /dev/null
+++ b/0003-fix-kernel-path.patch
@@ -0,0 +1,111 @@
+From da7d39963e0bacf212aa05dbe3d5326d81eb0559 Mon Sep 17 00:00:00 2001
+From: Frank Du <frank.du@intel.com>
+Date: Thu, 2 Mar 2023 13:14:14 +0800
+Subject: [PATCH 3/3] fix kernel path
+
+Signed-off-by: Frank Du <frank.du@intel.com>
+---
+ test/rist/test_receive.c   |  2 +-
+ test/rist/test_util.c      | 10 +++++-----
+ test/rist/test_util.h      |  2 +-
+ test/rist/ufd_receive.json |  2 ++
+ test/rist/ufd_send.json    |  2 ++
+ 5 files changed, 11 insertions(+), 7 deletions(-)
+
+diff --git a/test/rist/test_receive.c b/test/rist/test_receive.c
+index e9f9412..e298a8e 100644
+--- a/test/rist/test_receive.c
++++ b/test/rist/test_receive.c
+@@ -88,7 +88,7 @@ static int recver_init(struct test_ctx *ctx, struct recv_session_ctx *s) {
+ 
+   rist_receiver_set_output_fifo_size(r_ctx, ctx->rx_fifo_size);
+ 
+-  snprintf(s->url, sizeof(s->url), "rist://@%s:%d", ctx->dip,
++  snprintf(s->url, sizeof(s->url), "rist://@%s:%d", ctx->bind_ip,
+            ctx->udp_port + idx * 2);
+   struct rist_peer_config *peer_config = NULL;
+   ret = rist_parse_address2(s->url, &peer_config);
+diff --git a/test/rist/test_util.c b/test/rist/test_util.c
+index f316d86..1a75cc5 100644
+--- a/test/rist/test_util.c
++++ b/test/rist/test_util.c
+@@ -16,7 +16,7 @@ enum test_args_cmd {
+   TEST_ARG_SLEEP_STEP,
+   TEST_ARG_RX_FIFO_SIZE,
+   TEST_ARG_DIP,
+-  TEST_ARG_SIP,
++  TEST_ARG_BIND_IP,
+ 
+   TEST_ARG_MAX,
+ };
+@@ -28,7 +28,7 @@ static struct option test_args_options[] = {
+     {"sleep_step", required_argument, 0, TEST_ARG_SLEEP_STEP},
+     {"rx_fifo_size", required_argument, 0, TEST_ARG_RX_FIFO_SIZE},
+     {"dip", required_argument, 0, TEST_ARG_DIP},
+-    {"sip", required_argument, 0, TEST_ARG_SIP},
++    {"bind_ip", required_argument, 0, TEST_ARG_BIND_IP},
+ 
+     {0, 0, 0, 0}};
+ 
+@@ -60,8 +60,8 @@ static int test_parse_args(struct test_ctx *ctx, int argc, char **argv) {
+     case TEST_ARG_DIP:
+       strncpy(ctx->dip, optarg, sizeof(ctx->dip));
+       break;
+-    case TEST_ARG_SIP:
+-      strncpy(ctx->sip, optarg, sizeof(ctx->dip));
++    case TEST_ARG_BIND_IP:
++      strncpy(ctx->bind_ip, optarg, sizeof(ctx->dip));
+       break;
+     case '?':
+       break;
+@@ -100,7 +100,7 @@ int test_init_with_args(struct test_ctx *ctx, int argc, char **argv) {
+   ctx->stat_period_s = 5;
+   ctx->rx_fifo_size = 1024 * 1024;
+   snprintf(ctx->dip, sizeof(ctx->dip), "%s", "127.0.0.1");
+-  snprintf(ctx->sip, sizeof(ctx->dip), "%s", "127.0.0.1");
++  snprintf(ctx->bind_ip, sizeof(ctx->dip), "%s", "127.0.0.1");
+ 
+   test_parse_args(ctx, argc, argv);
+ 
+diff --git a/test/rist/test_util.h b/test/rist/test_util.h
+index 7d50e27..fd8c7ec 100644
+--- a/test/rist/test_util.h
++++ b/test/rist/test_util.h
+@@ -46,7 +46,7 @@ struct test_ctx {
+   int stat_period_s;
+   int rx_fifo_size;
+   char dip[64]; /* dst ip for tx */
+-  char sip[64]; /* source ip for rx */
++  char bind_ip[64]; /* bind ip for rx, only for kernel socket */
+ 
+   bool exit;
+ };
+diff --git a/test/rist/ufd_receive.json b/test/rist/ufd_receive.json
+index 685919a..f2b8286 100644
+--- a/test/rist/ufd_receive.json
++++ b/test/rist/ufd_receive.json
+@@ -2,6 +2,8 @@
+     "nb_udp_sockets" : "64",
+     "nb_nic_queues" : "64",
+     "nic_queue_rate_limit_g": 10,
++    "nic_shared_queues": false,
++    "udp_lcore": false,
+     "interfaces": [
+         {
+             "port": "0000:af:01.0",
+diff --git a/test/rist/ufd_send.json b/test/rist/ufd_send.json
+index 552d3b0..c67747d 100644
+--- a/test/rist/ufd_send.json
++++ b/test/rist/ufd_send.json
+@@ -2,6 +2,8 @@
+     "nb_udp_sockets" : "64",
+     "nb_nic_queues" : "64",
+     "nic_queue_rate_limit_g": 10,
++    "nic_shared_queues": false,
++    "udp_lcore": false,
+     "interfaces": [
+         {
+             "port": "0000:af:01.1",
+-- 
+2.34.1
+
diff --git a/test/rist/meson.build b/test/rist/meson.build
index 101bd1a..a9bb907 100644
--- a/test/rist/meson.build
+++ b/test/rist/meson.build
@@ -40,6 +40,25 @@ test_send_receive = executable('test_send_receive',
 									stdatomic_dependency
                                 ])
 
+test_send = executable('test_send',
+                                'test_send.c', 'test_util.c',
+                                extra_sources,
+                                include_directories: inc,
+                                link_with: librist,
+                                dependencies: [
+                                    threads,
+                                    stdatomic_dependency
+                                ])
+
+test_receive = executable('test_receive',
+                                'test_receive.c', 'test_util.c',
+                                extra_sources,
+                                include_directories: inc,
+                                link_with: librist,
+                                dependencies: [
+                                    threads,
+                                    stdatomic_dependency
+                                ])
 
 if comockatests
     test('rist test', risttest)
diff --git a/test/rist/test_receive.c b/test/rist/test_receive.c
new file mode 100644
index 0000000..e298a8e
--- /dev/null
+++ b/test/rist/test_receive.c
@@ -0,0 +1,245 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2023 Intel Corporation
+ */
+
+#include "librist/librist.h"
+#include "rist-private.h"
+
+#include "test_util.h"
+
+struct recv_session_ctx {
+  struct test_ctx *parent;
+  int idx;
+  bool exit;
+  char url[64 * 2]; /* rist://@192.168.85.61:1234 */
+
+  struct rist_logging_settings *r_log;
+  struct rist_ctx *r_ctx;
+  struct rist_peer_config *r_peer_config;
+  struct rist_peer *r_peer;
+
+  pthread_t worker;
+
+  int stat_recv_cnt;
+  int stat_recv_wrong_cnt;
+  int stat_recv_size;
+};
+
+static int recv_log_cb(void *arg, int level, const char *msg) {
+  struct recv_session_ctx *s = arg;
+  int idx = s->idx;
+
+  if (level > RIST_LOG_ERROR)
+    info("recver(%d): %s", idx, msg);
+  if (level <= RIST_LOG_ERROR) {
+    err("recver(%d), error: %s", idx, msg);
+    s->exit = true;
+  }
+  return 0;
+}
+
+static int recver_uinit(struct recv_session_ctx *s) {
+  int idx = s->idx;
+
+  dbg("%s(%d), start\n", __func__, idx);
+  if (s->r_peer) {
+    dbg("%s(%d), rist_peer_destroy\n", __func__, idx);
+    // rist_peer_destroy(s->r_ctx, s->r_peer);
+    s->r_peer = NULL;
+  }
+  if (s->r_ctx) {
+    info("%s(%d), rist_destroy\n", __func__, idx);
+    rist_destroy(s->r_ctx);
+    s->r_ctx = NULL;
+  }
+  if (s->r_peer_config) {
+    free(s->r_peer_config);
+    s->r_peer_config = NULL;
+  }
+  if (s->r_log) {
+    free(s->r_log);
+    s->r_log = NULL;
+  }
+  info("%s(%d), succ\n", __func__, idx);
+  return 0;
+}
+
+static int recver_init(struct test_ctx *ctx, struct recv_session_ctx *s) {
+  struct rist_ctx *r_ctx = NULL;
+  struct rist_logging_settings *log = NULL;
+  int idx = s->idx;
+  int ret;
+
+  ret = rist_logging_set(&log, RIST_LOG_INFO, recv_log_cb, s, NULL, stderr);
+  if (ret < 0) {
+    err("%s(%d), rist_logging_set fail %d\n", __func__, idx, ret);
+    recver_uinit(s);
+    return ret;
+  }
+  s->r_log = log;
+
+  ret = rist_receiver_create(&r_ctx, ctx->profile, log);
+  if (ret < 0) {
+    err("%s(%d), rist_recver_create fail %d\n", __func__, idx, ret);
+    recver_uinit(s);
+    return ret;
+  }
+  s->r_ctx = r_ctx;
+
+  rist_receiver_set_output_fifo_size(r_ctx, ctx->rx_fifo_size);
+
+  snprintf(s->url, sizeof(s->url), "rist://@%s:%d", ctx->bind_ip,
+           ctx->udp_port + idx * 2);
+  struct rist_peer_config *peer_config = NULL;
+  ret = rist_parse_address2(s->url, &peer_config);
+  if (ret < 0) {
+    err("%s(%d), rist_parse_address2 fail %d\n", __func__, idx, ret);
+    recver_uinit(s);
+    return ret;
+  }
+  s->r_peer_config = peer_config;
+
+  struct rist_peer *peer;
+  ret = rist_peer_create(r_ctx, &peer, s->r_peer_config);
+  if (ret < 0) {
+    err("%s(%d), rist_peer_create fail %d\n", __func__, idx, ret);
+    recver_uinit(s);
+    return ret;
+  }
+  s->r_peer = peer;
+
+  ret = rist_start(r_ctx);
+  if (ret < 0) {
+    err("%s(%d), rist_start fail %d\n", __func__, idx, ret);
+    recver_uinit(s);
+    return ret;
+  }
+
+  return 0;
+}
+
+static double recver_status(struct recv_session_ctx *s) {
+  int idx = s->idx;
+  int recv_cnt = s->stat_recv_cnt;
+  int recv_sz = s->stat_recv_size;
+  double bps = (double)recv_sz * 8 / s->parent->stat_period_s;
+  double bps_g = bps / (1000 * 1000 * 1000);
+
+  info("%s(%d), Recv %d pkts(%f g/s), wrong %d\n", __func__, idx, recv_cnt,
+       bps_g, s->stat_recv_wrong_cnt);
+  s->stat_recv_cnt = 0;
+  s->stat_recv_size = 0;
+  s->stat_recv_wrong_cnt = 0;
+  return bps_g;
+}
+
+static PTHREAD_START_FUNC(recver_worker, arg) {
+  struct recv_session_ctx *s = arg;
+  int idx = s->idx;
+  struct test_ctx *parent = s->parent;
+  uint16_t recv_idx = 0; /* only 16bit seq idx in the rtp */
+  char buffer[1460] = {0};
+  struct rist_data_block *b = NULL;
+
+  info("%s(%d), start\n", __func__, idx);
+  while (!parent->exit && !s->exit) {
+    int read = rist_receiver_data_read2(s->r_ctx, &b, 5);
+    dbg("%s(%d), read %d\n", __func__, idx, read);
+    if (read <= 0)
+      continue;
+    sprintf(buffer, "DEADBEAF TEST PACKET #%u", recv_idx);
+    if (strcmp(buffer, b->payload)) {
+      dbg("%s(%d), wrong content at pkt %u, seq %lu\n", __func__, idx, recv_idx,
+          b->seq);
+      dbg("%s(%d), payload: %s\n", __func__, idx, (char *)b->payload);
+      recv_idx = b->seq;
+      s->stat_recv_wrong_cnt++;
+    }
+    recv_idx++;
+
+    s->stat_recv_cnt++;
+    s->stat_recv_size += b->payload_len;
+    rist_receiver_data_block_free2(&b);
+  }
+  info("%s(%d), stop\n", __func__, idx);
+
+  return 0;
+}
+
+int main(int argc, char *argv[]) {
+  struct test_ctx ctx;
+  int ret;
+
+  memset(&ctx, 0, sizeof(ctx));
+  ret = test_init_with_args(&ctx, argc, argv);
+  if (ret < 0)
+    return ret;
+  info("%s: sessions cnt %u\n", __func__, ctx.sessions);
+
+  int sessions = ctx.sessions;
+  struct recv_session_ctx **apps;
+  apps = test_zmalloc(sizeof(*apps) * sessions);
+  if (!apps) {
+    err("%s, apps malloc fail\n", __func__);
+    return -ENOMEM;
+  }
+
+  for (int i = 0; i < sessions; i++) {
+    struct recv_session_ctx *app = test_zmalloc(sizeof(*app));
+    if (!app) {
+      err("%s(%d), ctx malloc fail\n", __func__, i);
+      ret = -ENOMEM;
+      goto exit;
+    }
+    apps[i] = app;
+
+    app->idx = i;
+    app->worker = -1;
+    app->parent = &ctx;
+
+    ret = recver_init(&ctx, app);
+    if (ret < 0) {
+      err("%s(%d), recver_init fail %d\n", __func__, i, ret);
+      goto exit;
+    }
+
+    ret = pthread_create(&app->worker, NULL, recver_worker, app);
+    if (ret < 0) {
+      err("%s(%d), worker create fail %d\n", __func__, i, ret);
+      goto exit;
+    }
+  }
+
+  int time_s = 0;
+  while (!ctx.exit) {
+    sleep(1);
+    /* display server status every stat_period_s */
+    time_s++;
+    if ((time_s % ctx.stat_period_s) == 0) {
+      double bps_g = 0;
+      for (int i = 0; i < sessions; i++) {
+        bps_g += recver_status(apps[i]);
+      }
+      info("%s, total %f g/s\n", __func__, bps_g);
+    }
+  }
+
+  ret = 0;
+  info("%s, exit now\n", __func__);
+
+exit:
+  ctx.exit = true;
+  for (int i = 0; i < sessions; i++) {
+    struct recv_session_ctx *app = apps[i];
+    if (app) {
+      if (app->worker > 0) {
+        app->exit = true;
+        pthread_join(app->worker, NULL);
+      }
+      recver_uinit(app);
+      test_free(app);
+    }
+  }
+  test_free(apps);
+  return ret;
+}
diff --git a/test/rist/test_send.c b/test/rist/test_send.c
new file mode 100644
index 0000000..5b89699
--- /dev/null
+++ b/test/rist/test_send.c
@@ -0,0 +1,236 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2023 Intel Corporation
+ */
+
+#include "librist/librist.h"
+#include "rist-private.h"
+
+#include "test_util.h"
+
+#define TX_UDP_LEN (1024 + 256)
+
+struct send_session_ctx {
+  struct test_ctx *parent;
+  int idx;
+  bool exit;
+  char url[64 * 2]; /* rist://192.168.85.61:1234 */
+
+  struct rist_logging_settings *r_log;
+  struct rist_ctx *r_ctx;
+  struct rist_peer_config *r_peer_config;
+  struct rist_peer *r_peer;
+
+  pthread_t worker;
+
+  int stat_send_cnt;
+};
+
+static int send_log_cb(void *arg, int level, const char *msg) {
+  struct send_session_ctx *s = arg;
+  int idx = s->idx;
+
+  if (level > RIST_LOG_ERROR)
+    info("sender(%d): %s", idx, msg);
+  if (level <= RIST_LOG_ERROR) {
+    err("sender(%d), error: %s", idx, msg);
+    s->exit = true;
+  }
+  return 0;
+}
+
+static int sender_uinit(struct send_session_ctx *s) {
+  if (s->r_peer) {
+    rist_peer_destroy(s->r_ctx, s->r_peer);
+    s->r_peer = NULL;
+  }
+  if (s->r_ctx) {
+    rist_destroy(s->r_ctx);
+    s->r_ctx = NULL;
+  }
+  if (s->r_peer_config) {
+    free(s->r_peer_config);
+    s->r_peer_config = NULL;
+  }
+  if (s->r_log) {
+    free(s->r_log);
+    s->r_log = NULL;
+  }
+  return 0;
+}
+
+static int sender_init(struct test_ctx *ctx, struct send_session_ctx *s) {
+  struct rist_ctx *r_ctx = NULL;
+  struct rist_logging_settings *log = NULL;
+  int idx = s->idx;
+  int ret;
+
+  ret = rist_logging_set(&log, RIST_LOG_INFO, send_log_cb, s, NULL, stderr);
+  if (ret < 0) {
+    err("%s(%d), rist_logging_set fail %d\n", __func__, idx, ret);
+    sender_uinit(s);
+    return ret;
+  }
+  s->r_log = log;
+
+  ret = rist_sender_create(&r_ctx, ctx->profile, 0, log);
+  if (ret < 0) {
+    err("%s(%d), rist_sender_create fail %d\n", __func__, idx, ret);
+    sender_uinit(s);
+    return ret;
+  }
+  s->r_ctx = r_ctx;
+
+  snprintf(s->url, sizeof(s->url), "rist://%s:%d", ctx->dip,
+           ctx->udp_port + idx * 2);
+  struct rist_peer_config *peer_config = NULL;
+  ret = rist_parse_address2(s->url, &peer_config);
+  if (ret < 0) {
+    err("%s(%d), rist_parse_address2 fail %d\n", __func__, idx, ret);
+    sender_uinit(s);
+    return ret;
+  }
+  s->r_peer_config = peer_config;
+
+  struct rist_peer *peer;
+  ret = rist_peer_create(r_ctx, &peer, s->r_peer_config);
+  if (ret < 0) {
+    err("%s(%d), rist_peer_create fail %d\n", __func__, idx, ret);
+    sender_uinit(s);
+    return ret;
+  }
+  s->r_peer = peer;
+
+  ret = rist_start(r_ctx);
+  if (ret < 0) {
+    err("%s(%d), rist_start fail %d\n", __func__, idx, ret);
+    sender_uinit(s);
+    return ret;
+  }
+
+  return 0;
+}
+
+static double sender_status(struct send_session_ctx *s) {
+  int idx = s->idx;
+  int send_cnt = s->stat_send_cnt;
+  double bps = (double)send_cnt * TX_UDP_LEN * 8 / s->parent->stat_period_s;
+  double bps_g = bps / (1000 * 1000 * 1000);
+
+  info("%s(%d), Send %d pkts(%f g/s)\n", __func__, idx, send_cnt, bps_g);
+  s->stat_send_cnt = 0;
+  return bps_g;
+}
+
+static PTHREAD_START_FUNC(sender_worker, arg) {
+  struct send_session_ctx *s = arg;
+  int idx = s->idx;
+  struct test_ctx *parent = s->parent;
+  uint16_t send_idx = 0;
+  char buffer[TX_UDP_LEN] = {0};
+  struct rist_data_block data = {0};
+
+  info("%s(%d), start\n", __func__, idx);
+  while (!parent->exit && !s->exit) {
+    sprintf(buffer, "DEADBEAF TEST PACKET #%u", send_idx);
+    data.payload = &buffer;
+    data.payload_len = sizeof(buffer);
+    int ret = rist_sender_data_write(s->r_ctx, &data);
+    if (ret < 0 || ret != (int)data.payload_len) {
+      err("%s(%d), rist_sender_data_write fail %d\n", __func__, idx, ret);
+      break;
+    }
+
+    send_idx++;
+    s->stat_send_cnt++;
+    if (parent->sleep_us) {
+      if (parent->sleep_step > 1) {
+        if ((send_idx % parent->sleep_step) == 0) {
+          usleep(parent->sleep_us);
+        }
+      } else {
+        usleep(parent->sleep_us);
+      }
+    }
+  }
+  info("%s(%d), stop\n", __func__, idx);
+
+  return 0;
+}
+
+int main(int argc, char *argv[]) {
+  struct test_ctx ctx;
+  int ret;
+
+  memset(&ctx, 0, sizeof(ctx));
+  ret = test_init_with_args(&ctx, argc, argv);
+  if (ret < 0)
+    return ret;
+  info("%s: sessions cnt %u\n", __func__, ctx.sessions);
+
+  int sessions = ctx.sessions;
+  struct send_session_ctx **apps;
+  apps = test_zmalloc(sizeof(*apps) * sessions);
+  if (!apps) {
+    err("%s, apps malloc fail\n", __func__);
+    return -ENOMEM;
+  }
+
+  for (int i = 0; i < sessions; i++) {
+    struct send_session_ctx *app = test_zmalloc(sizeof(*app));
+    if (!app) {
+      err("%s(%d), ctx malloc fail\n", __func__, i);
+      ret = -ENOMEM;
+      goto exit;
+    }
+    apps[i] = app;
+
+    app->idx = i;
+    app->worker = -1;
+    app->parent = &ctx;
+
+    ret = sender_init(&ctx, app);
+    if (ret < 0) {
+      err("%s(%d), sender_init fail %d\n", __func__, i, ret);
+      goto exit;
+    }
+
+    ret = pthread_create(&app->worker, NULL, sender_worker, app);
+    if (ret < 0) {
+      err("%s(%d), worker create fail %d\n", __func__, i, ret);
+      goto exit;
+    }
+  }
+
+  int time_s = 0;
+  while (!ctx.exit) {
+    sleep(1);
+    /* display server status every stat_period_s */
+    time_s++;
+    if ((time_s % ctx.stat_period_s) == 0) {
+      double bps_g = 0;
+      for (int i = 0; i < sessions; i++) {
+        bps_g += sender_status(apps[i]);
+      }
+      info("%s, total %f g/s\n", __func__, bps_g);
+    }
+  }
+
+  ret = 0;
+  info("%s, exit now\n", __func__);
+
+exit:
+  ctx.exit = true;
+  for (int i = 0; i < sessions; i++) {
+    struct send_session_ctx *app = apps[i];
+    if (app) {
+      if (app->worker > 0) {
+        app->exit = true;
+        pthread_join(app->worker, NULL);
+      }
+      sender_uinit(app);
+      test_free(app);
+    }
+  }
+  test_free(apps);
+  return ret;
+}
diff --git a/test/rist/test_util.c b/test/rist/test_util.c
new file mode 100644
index 0000000..1a75cc5
--- /dev/null
+++ b/test/rist/test_util.c
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2023 Intel Corporation
+ */
+
+#include "test_util.h"
+
+#include <getopt.h>
+#include <signal.h>
+
+enum test_args_cmd {
+  TEST_ARG_UNKNOWN = 0,
+
+  TEST_ARG_PROFILE = 0x100, /* start from end of ascii */
+  TEST_ARG_SESSIONS_CNT,
+  TEST_ARG_SLEEP_US,
+  TEST_ARG_SLEEP_STEP,
+  TEST_ARG_RX_FIFO_SIZE,
+  TEST_ARG_DIP,
+  TEST_ARG_BIND_IP,
+
+  TEST_ARG_MAX,
+};
+
+static struct option test_args_options[] = {
+    {"profile", required_argument, 0, TEST_ARG_PROFILE},
+    {"sessions_cnt", required_argument, 0, TEST_ARG_SESSIONS_CNT},
+    {"sleep_us", required_argument, 0, TEST_ARG_SLEEP_US},
+    {"sleep_step", required_argument, 0, TEST_ARG_SLEEP_STEP},
+    {"rx_fifo_size", required_argument, 0, TEST_ARG_RX_FIFO_SIZE},
+    {"dip", required_argument, 0, TEST_ARG_DIP},
+    {"bind_ip", required_argument, 0, TEST_ARG_BIND_IP},
+
+    {0, 0, 0, 0}};
+
+static int test_parse_args(struct test_ctx *ctx, int argc, char **argv) {
+  int cmd = -1, optIdx = 0;
+
+  while (1) {
+    cmd = getopt_long_only(argc, argv, "hv", test_args_options, &optIdx);
+    if (cmd == -1)
+      break;
+    dbg("%s, cmd %d %s\n", __func__, cmd, optarg);
+
+    switch (cmd) {
+    case TEST_ARG_PROFILE:
+      ctx->profile = atoi(optarg);
+      break;
+    case TEST_ARG_SESSIONS_CNT:
+      ctx->sessions = atoi(optarg);
+      break;
+    case TEST_ARG_SLEEP_US:
+      ctx->sleep_us = atoi(optarg);
+      break;
+    case TEST_ARG_SLEEP_STEP:
+      ctx->sleep_step = atoi(optarg);
+      break;
+    case TEST_ARG_RX_FIFO_SIZE:
+      ctx->rx_fifo_size = atoi(optarg);
+      break;
+    case TEST_ARG_DIP:
+      strncpy(ctx->dip, optarg, sizeof(ctx->dip));
+      break;
+    case TEST_ARG_BIND_IP:
+      strncpy(ctx->bind_ip, optarg, sizeof(ctx->dip));
+      break;
+    case '?':
+      break;
+    default:
+      break;
+    }
+  };
+
+  return 0;
+}
+
+static struct test_ctx *g_test_ctx;
+static void test_sig_handler(int signo) {
+  struct test_ctx *ctx = g_test_ctx;
+  info("%s, signal %d\n", __func__, signo);
+
+  switch (signo) {
+  case SIGINT: /* Interrupt from keyboard */
+    ctx->exit = true;
+    break;
+  }
+
+  return;
+}
+
+int test_init_with_args(struct test_ctx *ctx, int argc, char **argv) {
+  g_test_ctx = ctx;
+  signal(SIGINT, test_sig_handler);
+
+  /* default value */
+  ctx->sessions = 1;
+  ctx->profile = 0; /* simple */
+  ctx->udp_port = 1234;
+  ctx->sleep_us = 100;
+  ctx->sleep_step = 1;
+  ctx->stat_period_s = 5;
+  ctx->rx_fifo_size = 1024 * 1024;
+  snprintf(ctx->dip, sizeof(ctx->dip), "%s", "127.0.0.1");
+  snprintf(ctx->bind_ip, sizeof(ctx->dip), "%s", "127.0.0.1");
+
+  test_parse_args(ctx, argc, argv);
+
+  return 0;
+}
diff --git a/test/rist/test_util.h b/test/rist/test_util.h
new file mode 100644
index 0000000..fd8c7ec
--- /dev/null
+++ b/test/rist/test_util.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2023 Intel Corporation
+ */
+
+#ifndef _TEST_UTIL_H_
+#define _TEST_UTIL_H_
+
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+/* log define */
+#ifdef DEBUG
+#define dbg(...)                                                               \
+  do {                                                                         \
+    printf(__VA_ARGS__);                                                       \
+  } while (0)
+#else
+#define dbg(...)                                                               \
+  do {                                                                         \
+  } while (0)
+#endif
+#define info(...)                                                              \
+  do {                                                                         \
+    printf(__VA_ARGS__);                                                       \
+  } while (0)
+#define warn(...)                                                              \
+  do {                                                                         \
+    printf(__VA_ARGS__);                                                       \
+  } while (0)
+#define err(...)                                                               \
+  do {                                                                         \
+    printf(__VA_ARGS__);                                                       \
+  } while (0)
+
+struct test_ctx {
+  int profile;
+  int sessions; /* number of sessions */
+  int udp_port;
+  int sleep_us;
+  int sleep_step;
+  int stat_period_s;
+  int rx_fifo_size;
+  char dip[64]; /* dst ip for tx */
+  char bind_ip[64]; /* bind ip for rx, only for kernel socket */
+
+  bool exit;
+};
+
+int test_init_with_args(struct test_ctx *ctx, int argc, char **argv);
+
+static inline void *test_zmalloc(size_t sz) {
+  void *p = malloc(sz);
+  if (p)
+    memset(p, 0x0, sz);
+  return p;
+}
+
+static inline void test_free(void *p) { free(p); }
+
+#endif
diff --git a/test/rist/ufd_receive.json b/test/rist/ufd_receive.json
new file mode 100644
index 0000000..f2b8286
--- /dev/null
+++ b/test/rist/ufd_receive.json
@@ -0,0 +1,13 @@
+{
+    "nb_udp_sockets" : "64",
+    "nb_nic_queues" : "64",
+    "nic_queue_rate_limit_g": 10,
+    "nic_shared_queues": false,
+    "udp_lcore": false,
+    "interfaces": [
+        {
+            "port": "0000:af:01.0",
+            "ip": "192.168.85.80"
+        }
+    ],
+}
diff --git a/test/rist/ufd_send.json b/test/rist/ufd_send.json
new file mode 100644
index 0000000..c67747d
--- /dev/null
+++ b/test/rist/ufd_send.json
@@ -0,0 +1,13 @@
+{
+    "nb_udp_sockets" : "64",
+    "nb_nic_queues" : "64",
+    "nic_queue_rate_limit_g": 10,
+    "nic_shared_queues": false,
+    "udp_lcore": false,
+    "interfaces": [
+        {
+            "port": "0000:af:01.1",
+            "ip": "192.168.85.60"
+        }
+    ],
+}
-- 
2.34.1

